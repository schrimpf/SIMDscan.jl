var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/#Cumulative-Sum","page":"Benchmarks","title":"Cumulative Sum","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BenchmarkTools, CpuId, SIMDscan\nN = 10_000\nx = rand(N);\nnothing","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"cpuinfo()\n@benchmark cumsum!($(copy(x)),$x)\n@benchmark scan_serial!(+,$(copy(x)))\n@benchmark scan_simd!(+,$(copy(x)), Val(16))","category":"page"},{"location":"benchmarks/#AR(1)","page":"Benchmarks","title":"AR(1)","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"T = 2500\nϵ = randn(T)\ny = similar(ϵ)\nα = 0.9\nfunction ar1recursize!(y, ϵ, α)\n    y[1] = ϵ[1]\n    for t = 2:T \n        y[t] = α*y[t-1] + ϵ[t]\n    end \n    y\nend\nar(y,e) = (e[1] + α*y[1]*e[2], α*y[2]*e[2]);\nnothing","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"@benchmark ar1recursize!($y,$ϵ,$α)\n@benchmark scan_serial!($ar, $((copy(ϵ), ones(T))))\n@benchmark scan_simd!($ar, $((copy(ϵ), ones(T))), identity=$((0.0,1.0/α)))","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"<div class=\"citation canonical\"><ul><li>\n<div id=\"nash2021\">Nash, J.; Bezanson, J. and Pamnany, K. (2021). <a href='https://proceedings.juliacon.org/papers/10.21105/jcon.00054.pdf'><i>Basic Threading Examples in JuliaLang v1. 3</i></a>. In: Proceedings of the JuliaCon Conferences, 54.</div>\n</li><li>\n<div id=\"slotin2022\">Slotin, S. (2023). <a href='https://en.algorithmica.org/hpc/algorithms/prefix/'><i>Prefix Sum with SIMD</i></a>. In: Algorithms for Modern Hardware, editors, . Sergey Slotin.</div>\n</li>\n</ul></div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = SIMDscan","category":"page"},{"location":"#SIMDscan","page":"Home","title":"SIMDscan","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for SIMDscan.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides code for doing a scan using SIMD instructions. Scans are also known as prefix operations.   The Base Julia function accumulate performs the same operation. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given a sequence x_1 x_2   x_n, and an associative operator, oplus, the the scan is","category":"page"},{"location":"","page":"Home","title":"Home","text":"x_1 x_1 oplus x_2 x_3 oplus x_2 oplus x_1   x_n oplus x_n-1 oplus cdots oplus x_1","category":"page"},{"location":"","page":"Home","title":"Home","text":"For parallelization, it is essential that oplus be associative. The function scan_simd!(⊕, x)  computes the scan of x in place. ","category":"page"},{"location":"#Warnings","page":"Home","title":"Warnings","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"x must be indexed from 1 to length(x). \n⊕ must be associative for scan_simd! ","category":"page"},{"location":"#Multivariate-Operations","page":"Home","title":"Multivariate Operations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There is also a method for scanning  mathbbmRᴷmathbbmRᴷ. In this case, ⊕ should accept two K tuples as arguments and a K-tuple.  x should be a NTuple{K,AbstractVector} where each element of the tuple is the sequence of values.  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The multivariate scan can be used to simulate an AR(1) model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using SIMDscan  # hide\nT = 10\nϵ = randn(T)\n# simple recursive version for comparison\ny = similar(ϵ)\ny[1] = ϵ[1]\nα = 0.5\nfor t = 2:T \n  y[t] = α*y[t-1] + ϵ[t]\nend \n\n# to make ⊕ associative, augment ϵ[t] with a second element that keeps track of the appropriate power of α\n⊕(y,e) = (e[1] + α*y[1]*e[2], α*y[2]*e[2])\nid = (0.0,1.0/α) # a left identity; ⊕(id,x) = x ∀ x\nyscansimd,at = scan_simd!(⊕, (copy(ϵ), ones(T)), identity=id)\n[y yscansimd]","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following sources were helpful while developing this package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Slotin, 2023) describes an SIMD implementation for prefix sum with C code\n(Nash *et al.*, 2021) has example code for a threaded scan (prefix sum) in Julia,","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Functions","page":"Home","title":"Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [SIMDscan]","category":"page"},{"location":"#SIMDscan.scan_serial!-Union{Tuple{F}, Tuple{F, AbstractVector}} where F<:Function","page":"Home","title":"SIMDscan.scan_serial!","text":"scan_serial!(f::F,x::AbstractVector) where {F <: Function}\n\nReplaces the vector x with the scan of x using f. That is,\n\nbeginbmatrix\nx1 \nf(x2x1) \nf(x3f(x2x1)) \n\nendbmatrix\n\n Examples\n\njl-doctest julia> scan_serial!(+,[1,2,3,4]) 4-element Vector{Int64}:   1   3   6  10 ```\n\n\n\n\n\n","category":"method"},{"location":"#SIMDscan.scan_serial!-Union{Tuple{T}, Tuple{K}, Tuple{F}, Tuple{F, Tuple{Vararg{AbstractVector{T}, K}}}} where {F<:Function, K, T}","page":"Home","title":"SIMDscan.scan_serial!","text":"scan_serial!(f::F,x::NTuple{K, AbstractVector{T}}) where {F <: Function, K, T}\n\nIn place scan for a function that takes two K tuples as arguments.  Replaces the tuple of vectors x with the scan. \n\nExamples\n\njulia> scan_serial!((x,y)->(x[1]+y[1], x[2]*y[2]),([1,2,3,4],[1,2,3,4]))\n([1, 3, 6, 10], [1, 2, 6, 24])\n\n\n\n\n\n","category":"method"},{"location":"#SIMDscan.scan_simd!-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F, AbstractVector{T}}, Tuple{F, AbstractVector{T}, Val{N}}} where {F, T, N}","page":"Home","title":"SIMDscan.scan_simd!","text":"scan_simd!(f::F, x::AbstractVector{T}, v::Val{N}=Val(8);identity::T=zero(T)) where {F, T, N}\n\nIn place scan for an associative function. \n\nidentity should be a left identity under f. That is, f(identity, y) = y for all y.\n\nT, must be a type that can be loaded onto registers, i.e. one of SIMD.VecTypes. \n\nf must be associative. Otherwise, this will give incorrect results.\n\nVal(N) specifies the SIMD vector width used. The default of 8 should give good performance on CPUs with AVX512 for which 8 Float64s fill the 512 bits available. \n\nExamples\n\njulia> scan_simd!(+,[1,2,3,4])\n4-element Vector{Int64}:\n  1\n  3\n  6\n 10\n\n\n\n\n\n","category":"method"},{"location":"#SIMDscan.scan_simd!-Union{Tuple{N}, Tuple{T}, Tuple{K}, Tuple{F}, Tuple{F, Tuple{Vararg{AbstractVector{T}, K}}}, Tuple{F, Tuple{Vararg{AbstractVector{T}, K}}, Val{N}}} where {F, K, T, N}","page":"Home","title":"SIMDscan.scan_simd!","text":"scan_simd!(f::F, x::NTuple{K, AbstractVector{T}}, v::Val{N}=Val(8); identity::NTuple{K,T}=ntuple(i->zero(T),Val(K))) where {F, K, T, N}\n\nIn place scan for an associative function that takes two K tuples as arguments.  Replaces the tuple of vectors x with the scan. \n\nidentity should be a left identity under f. That is, f(identity, y) = y for all y.\n\nT, must be a type that can be loaded onto registers, i.e. one of SIMD.VecTypes. \n\nf must be associative. Otherwise, this will give incorrect results.\n\nVal(N) specifies the SIMD vector width used. The default of 8 should give good performance on CPUs with AVX512 for which 8 Float64s fill the 512 bits available. \n\nExamples\n\njulia> scan_simd!((x,y)->(x[1]+y[1], x[2]*y[2]),([1,2,3,4],[1,2,3,4]))\n([1, 3, 6, 10], [1, 2, 6, 24])\n\n\n\n\n\n","category":"method"}]
}
